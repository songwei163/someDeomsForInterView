散列表的插入、删除、查找的时间复杂度都可以做到常量级的O(1)，非常高效，而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？

1. 散列表中的数据是**无序**存储的，如果需要输出有序的数据，需要先排序。对于二叉查找树来说，则只需要进行中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据。
2. 散列表扩容耗时很多，当遇到散列冲突时，**性能不稳定**，尽管二叉查找树的性能不稳定，但在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。
3. 笼统地说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际查找的速度可能不一定比O(logn)快，加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
4. 哈希表的构造比二叉查找树要**复杂**，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

### 进程

#### 程序执行

1. 顺序执行
2. 并发执行

#### 进程的定义

* 进程是程序的一次执行
* 进程是一个程序及其数据再处理机上顺序执行时所发生的活动
* 进程是具有独立功能的程序再一个数据集合上运行的过程，它是系统进行`资源分配`和`调度`的独立单位

#### 进程的特征

* 动态性
* 并发性
* 独立性
* 异步性

#### 进程的基本状态

Ready状态

Running状态

Block状态

创建状态、终止状态

挂起操作的引入

#### 进程控制块PCB

#### 进程同步的基本概念

##### 两种形式的制约关系

- 间接相互制约关系

系统临界资源，互斥访问，统一分配，申请使用

- 直接相互制约关系

多个进程相互合作，引发的同步问题



##### 临界资源

许多硬件资源如打印机、磁带机等，都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享。

##### 临界区

无论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问。人们习惯把每个进程中访问临界资源的那段代码称为临界区

##### 同步机制应遵循的规则

**空闲让进**

当无进程处于临界区时，表示临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。

**忙则等待**

当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。


#### 二分查找

例子：猜字游戏

> 这是一个生活中的例子，我们现在回到实际的开发场景中。假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。

**二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。**

 **O(logn) 惊人的查找速度** 

 因为 logn 是一个**非常“恐怖”的数量级**，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。 

1. 循环退出条件

   >  注意是 low<=high，而不是 low 

2. mid 的取值

   > ​	 实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。 
>
   > 
   >
   >  3.low 和 high 的更新
   

​		low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死		循环。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。

 **二分查找应用场景的局限性** 

1.  首先，二分查找依赖的是顺序表结构，简单点说就是数组。 

   > 那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。

2.  其次，二分查找针对的是有序数据。 

   > 二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用

3.  再次，数据量太小不适合二分查找。 

   > 如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。

4.  最后，数据量太大也不适合二分查找。 

   > 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。